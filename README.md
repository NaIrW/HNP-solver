# HNP-solver

use Lattice based method to solve hnp, maybe more like a reimplementation from [bdd-predicate](https://github.com/malb/bdd-predicate)

this code is only used for my FYP

## requirements 

g6k  # note g6k-gpu cannot use

gmpy2, sympy, Crypto, ...

## use in python

```python
from hnp import HNP
from hnpSolver import Solver


hnp = HNP(256, 85, 3, prime_full=True)
solver = Solver(hnp, threads=24)
result = solver()
```

result will contain all solutions meeting the conditions, not only ONE solution

this may happened when the given information is not enough (socalled "information limit")

for example one want to recover a 256-bit hidden number, but you only give 85 equations, and each equation contains 3-bit information (85 * 3 = 255 < 256)

```python
# for hnp generated by yourself you can check by this
if hnp.x in result:  
    print('find hidden number !!!')
```

but try to jump out from hnp
I think one can check which solution is correct or the real solution is not in result by other method

## benchmark 

```
[+] LLL
[+] LLL done  cost: 1.7462794780731201 s
[+] bkz jump 20 to M.d-20
[+] bkz jump done  cost: 32.63479518890381 s
[+] bkz loop
[+] bkz loop done  cost: 188.56592988967896 s
[+] sieve
[+] sieve done  cost: 24.764126300811768 s
[+] fill database
[+] fill database done  cost: 9.085375547409058 s
[+] checking from the database with size 824961
[+] checking done  cost: 59.47186040878296 s
got 1
find hidden number!
322.11s/it
```

`HNP(256, 85, 3) Solver.threads=24` may cost 325s in AMD Ryzen 9 5900X

CPU is only fully loaded in sieve and checking database

multicore BKZ in FPLLL only takse about 2 cores so the BKZ tour cost more than 1/2 time
